/*
 *  corba.js Object Request Broker (ORB) and Interface Definition Language (IDL) compiler
 *  Copyright (C) 2018, 2020, 2021, 2024 Mark-Andr√© Hopf <mhopf@mark13.org>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import * as fs from "fs"
import { Type, Node } from "../idl-node"
import { filenamePrefix, filename, filenameLocal, hasValueType, typeIDLtoGIOP, FileType } from "../util"
import { typeIDLtoCC } from "./typeIDLtoCC"

export function writeCCStub(specification: Node): void {
    let out = fs.createWriteStream(filenamePrefix + "_stub.hh")
    out.write("// This file is generated by the corba.js IDL compiler from '" + filename + "'.\n\n")
    out.write(`#pragma once\n`)
    out.write(`#include "../src/corba/corba.hh"\n`)
    out.write(`#include "../src/corba/orb.hh"\n`)
    out.write(`#include "../src/corba/giop.hh"\n`)
    out.write(`#include "../src/corba/coroutine.hh"\n`)
    out.write(`#include <vector>\n`)
    if (hasValueType(specification)) {
        out.write("import * as valuetype from \"./" + filenameLocal + "_valuetype\"\n")
    }
    out.write(`#include "${filenameLocal}.hh"\n\n`)

    writeCCStubDefinitions(out, specification)
}
function writeCCStubDefinitions(out: fs.WriteStream, specification: Node, prefix = "", indent = 0): void {
    for (let definition of specification.child) {
        switch (definition!.type) {
            case Type.TKN_MODULE:
                out.write("namespace " + definition!.text + " {\n\n")
                writeCCStubDefinitions(out, definition!, prefix + definition!.text + ".", indent + 1)
                out.write("} // namespace " + definition!.text + "\n\n")
                break

            case Type.SYN_INTERFACE: {
                let interface_dcl = definition!
                let identifier = interface_dcl.child[0]!.child[1]!.text
                let interface_body = interface_dcl.child[1]!

                out.write(`class ${identifier}_stub: public ${prefix}${identifier}, public CORBA::Stub {\n`)
                out.write(`public:\n`)
                out.write(`    ${identifier}_stub(CORBA::ORB *orb, const std::string &objectKey, CORBA::detail::Connection *connection): Stub(orb, objectKey, connection) {}\n`)
                out.write(`    const char *repository_id() const override { return "IDL:${prefix}${identifier}:1.0"; }\n`)

                // out.write(`    static narrow(object: any): ${prefix}${identifier} {\n`)
                // out.write(`        if (object instanceof ${prefix}${identifier})\n`)
                // out.write(`            return object as ${prefix}${identifier}\n`)
                // out.write(`        throw Error("${prefix}${identifier}.narrow() failed")\n`)
                // out.write(`    }\n\n`)

                for (let _export of interface_body.child) {
                    switch (_export!.type) {
                        case Type.SYN_OPERATION_DECLARATION: {
                            let op_dcl = _export!
                            let attribute = op_dcl.child[0]
                            let returnType = op_dcl.child[1]!

                            let oneway = false
                            if (attribute !== undefined && attribute.type === Type.TKN_ONEWAY)
                                oneway = true
                            if (oneway && returnType.type !== Type.TKN_VOID)
                                console.log("WARNING: corba.js currently requires every oneway function to return void")

                            let identifier = op_dcl.child[2]!.text
                            let parameter_decls = op_dcl.child[3]!.child

                            out.write("    virtual ")
                            if (oneway) {
                                out.write(`${typeIDLtoCC(returnType, FileType.INTERFACE)}`)
                            } else {
                                out.write(`CORBA::task<${typeIDLtoCC(returnType, FileType.INTERFACE)}>`)
                            }
                            out.write(` ${identifier}(`)
                            let comma = false
                            for (let parameter_dcl of parameter_decls) {
                                let attribute = parameter_dcl!.child[0]!.type
                                let type = parameter_dcl!.child[1]
                                let identifier = parameter_dcl!.child[2]!.text
                                // TODO: move this check into the parser or attach file, row & col to the parse tree nodes
                                if (attribute !== Type.TKN_IN) {
                                    throw Error("corba.js currently only supports 'in' parameters")
                                }
                                if (!comma) {
                                    comma = true
                                } else {
                                    out.write(", ")
                                }
                                out.write(`${typeIDLtoCC(type, FileType.INTERFACE)} ${identifier}`)
                            }
                            // if (oneway) {

                            // } else {
                                // out.write(`): Promise<${typeIDLtoCC(returnType, FileType.STUB)}> {\n`)
                                out.write(`) override {\n`)
                            // }
                            out.write("        ")
                            if (!oneway) {
                                out.write("return ")
                            }
   
                            // out.write(`await this.orb.call(this, ${oneway}, "${identifier}", [`)
                            // comma = false
                            // for (let parameter_dcl of parameter_decls) {
                            //     let identifier = parameter_dcl!.child[2]!.text
                            //     if (!comma) {
                            //         comma = true
                            //     } else {
                            //         out.write(", ")
                            //     }
                            //     out.write(identifier)
                            // }
                            // out.write("])\n")

                            // out.write("/*\n")
                            // out.write("        ")
                            if (oneway) {
                                out.write(`get_ORB()->onewayCall(this, "${identifier}", `)
                            } else {
                                if (returnType.type !== Type.TKN_VOID) {
                                    out.write(`get_ORB()->twowayCall<${typeIDLtoCC(returnType, FileType.INTERFACE)}>(this, "${identifier}", `)
                                } else {
                                    out.write(`get_ORB()->twowayCall(this, "${identifier}", `)
                                }
                            }

                            // encode
                            out.write(`[&](CORBA::GIOPEncoder &encoder) {\n`)
                            for (let parameter_dcl of parameter_decls) {
                                let type = parameter_dcl!.child[1]!
                                let identifier = parameter_dcl!.child[2]!.text
                                out.write(`            ${typeIDLtoGIOP(type, identifier)};\n`)
                            }
                           
                            if (oneway) {
                                out.write(`        });\n`)
                            } else {
                                if (returnType.type !== Type.TKN_VOID) {
                                    out.write(`        },\n`)
                                    out.write(`        `)
                                    out.write(`[&](CORBA::GIOPDecoder &decoder) { return ${typeIDLtoGIOP(returnType)}; });\n`)
                                } else {
                                    out.write(`        });\n`)
                                }
                            }
                            // out.write("*/\n")

                            out.write("    }\n")
                        } break
                        case Type.TKN_ATTRIBUTE: {
                        } break
                        default:
                            throw Error("yikes")
                    }
                }
                out.write("};\n\n")
            } break
        }
    }
}
